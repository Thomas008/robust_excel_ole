= RobustExcelOle

This ruby gem automates modifying, reading and writing Excel files.
It supports simultaneously running Excel instances and user interactions.
RobustExcelOle deals with various cases of Excel and user behaviour,
and implements workarounds for some Excel bugs.
The gem provides convenient methods for common tasks, and facilitates referenced libraries.
It supports Excel 2010.

RobustExcelOle works by sending VBA methods via Win32OLE.
Moreover, it implements a management system and keeps track of Excel files and Excel instances.
The tool is optimised with help of rcov.

== Requirements

* Ruby 1.8.6 or higher

== Install

  gem install robust_excel_ole

== Usage

  require 'robust_excel_ole'
  include RobustExcelOle

== Description  

In the following, some features of RobustExcelOle are depicted.

RobustExcelOle allows a "script mode" and an "interactive mode": Commands enable to open Excel files (or workbooks) in various Excel instances, enable to close, reopen, modify and save the Excel files, without the need of the user's interaction, and even without the user noticing. While running this script mode, the user can open and modify any Excel files in any Excel instances at any time. RobustExcelOle manages the complex cases of conflicts that might occur such that the user does not need to interfere and the script can continue.

For example, suppose you want to process a list of workbooks (Excel files). RobustExcelOle allows to rapidly open, manipulate, close and save these workbooks (script mode). Now assume, the workbook "workbook.xls" is being processed, while the user has opened this workbook, has manipulated but not saved it yet. Excel would prompt a message and ask the user what to do. RobustExcelOle solves this conflict by using several options that state whether the changes of the user should be saved (accepted) or discarded before opening the workbook. 

  book1 = Book.open('workbook.xls')  # user
    ...
  book2 = Book.open('workbook.xls', :if_unsaved => accept) # script

Similarly, if the user has opened a workbook that has the same name but a different path, the conflict is solved via options.

  book1 = Book.open('path1/workbook.xls')
    ...
  book2 = Book.open('workbook.xls', :if_obstructed => :forget)

Another feature that RobustExcelOle povides is reopening workbooks after closing them. A workbook is opened by default in the Excel instance where it was open before most recently. If this Excel instance is damaged or closed, then RobustExcelIle controls via options whether the workbook is opened in the current (active) Excel instance, a new or a given Excel instance, e.g.

  book1 = Book.open('workbook.xls', :default => {:excel => :new})

Moreover, RobustExcelOle allows unobtrusively reading and modifying workbooks, i.e. accessing workbooks without changing their "status". The status comprises whether the workbook is open or closed, saved or unsaved, read-only or writable, visible or invisible, calculation mode is manual or automatic, and checking compatibility is done or not done. 

  Book.for_modifying('workbook.xls') do |book|
    ...
  end

  Book.for_reading('workbook.xls') do |book|
    ...
  end

=== The Book objects and transperence identity

An Excel file (or workbook) is represented by a Book object. A Book object is defined by the full name of the workbook and the Excel instance in which it is opened. RobustExcelOle aims to ensure identity transperency.
Identity transparence means that the same Book objects refer to the same Excel files, and vice versa.
In other words, a Book objects is a proxy of an Excel file.

=== Opening and closing workbooks

Let's have a look at an example. Suppose, we want to open a workbook.

  book = Book.open('workbook.xls')

We could do this in a block as well. The semantics is similar to, e.g.,  +File.open+.

  Book.open('workbook.xls') do |book|
    # do something with book
  end

Now let's make the workbook visible.

  book.visible = true

We can do this in one step as well.

  book = Book.open('workbook.xls', :visible => true)

Now we want to open another workbook in a new Excel instance.

  book2 = Book.open('another_workbook.xls', :force => {:excel => :new}, :visible => true)

Then we open a third workbook in the second Excel instance. 

  book3 = Book.open('different_workbook.xls', :force => {:excel => book2.excel})

We close the second workbook.

  book2.close

Reopening this workbook is done by

  book2.reopen

=== Modifying workbooks

We can get the value of a named range.

  book2["new"]   # => foo

or

  book2.nameval("new")  # => "foo"

Now we assign a new value to this range.

  book2["new"] = "bar"

or

  book2.set_nameval("new", "bar")

Now we access the first worksheet by

  sheet1 = book2.sheet(1)

or 

  sheet1 = book2.sheet('Sheet1')

or
  
  sheet1 = book2.first_sheet

We can read the first three cells of the first row

  sheet1.row_range(1, 1..3).values   # => ["foo","workbook","sheet1"]

and the third column

  sheet1.col_range(3).values   # => ["sheet1", 2.0, 4.0]

Then we read first cell

  sheet1[1,1].value    # => "foo"

or

  sheet1.row_range(1)[0].value    # => "foo"

Then we modify it

  sheet1[1,1] = "hello"

We get the value of a range

  sheet1.nameval("firstcell")    # => "hello"

and set the value 

  sheet1.set_nameval("firstcell", "foo")

We get the value of a range of a locally defined name. 

  sheet1.rangeval("firstcell")     # => "foo"

or

  sheet1.rangeval("A1")    # => "foo"

Then we set the value of this range.

  sheet1.set_rangeval("firstcell", "bar")

We can copy the first worksheet, name it and add it before the third worksheet.

  book2.add_or_copy_sheet(sheet1, :as => "copied_name, :before => book2.last_sheet)

=== Saving workbooks

Simple save is done by

  book2.save

We could save the workbook under a different name, and overwrite, if a file with the same name exists.

  book2.save_as('example_workbook.xls', :if_exists => :overwrite)

Then we close this workbook.

  book2.close

Simple saving and closing can be also done in one step by

  book2.close(:if_unsaved => :save)

=== Operating on Excel instances.

Suppose we want to create an Excel object by connecting to the already running Excel instance.

  excel1 = Excel.current

or 

  excel1 = Excel.new(:reuse => true)  


Now we want to start a new, visible Excel instance.

  excel2 = Excel.create(:visible => true)

or 

  excel2 = Excel.new(:reuse => false, :visible => true)  

We open a workbook in this Excel instance.

  book4 = Book.open('more_data/workbook', {:force => {:excel => excel2}})

We can close Closing an Excel instance is dony by

  excel1.close

Closed Excel instances can be reopened.

  excel1.recreate(:reopen_workbooks => true, :visible => true)

We can get the value of a range in an Excel instance by

  excel2["firstcell"] => "foo"
  
or

  excel2.nameval("firstcell") = "foo"

and set the value of this range by using

  excel2["firstcell"] = "bar"

or

  excel2.set_nameval("firstcell", "bar")

We get and set the value of a range with a locally defined named by

  excel2.rangeval("firstcell")

and set its value by

  excel2.set_rangeval("firstcell, "bar")

Closing all Excel instances ist done by

  Excel.close_all(:if_unsaved => :forget)

Hard terminating all Excel processes is done by

  Excel.kill_all

=== More details

{Readme_detail.rdoc}[file:../Readme_detail.rdoc]

=== Want to do more things

If you want to do something that not provide a function, you can use win32ole methods.

== Support

Please contact us and to report issues and feature requests to github Issues. 
https://github.com/Thomas008/robust_excel_ole/issues

== Collaborate

Please pull request on github.

== Author

thomas mailto:Thomas.Raths@gmx.net

== License

MIT License. For more imformation, please see LICENSE.
