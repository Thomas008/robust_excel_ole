= RobustExcelOle

robust_excel_ole helps to automate modifying and reading Excel files.
This is done by sending VBA methods via Win32OLE.
Moreover, robust_excel_ole implements a management system and keeps track of Excel files and Excel instances

Goals:
- support both fully automated operations as well as simultaneous user interactions during the automation
- robust Excel AUtomation: be able to deal with all cases of Excel (and user) behaviour, encapsulate errors
- provide convenient methods for frequent (common) tasks
- support the use of simultaneously running Excel instances
- comprehensive wrapping of Excel using Win32OLE
- allow the presence of referenced libraries and provide some support for that
- support EXCEL 2010, EXCEL 2007

This is work in progress.

== Requirements

* Ruby 1.8.6 or higher

== Install

  gem install robust_excel_ole

== Usage

=== Opening a workbook.

Example:

  include RobustExcelOle
  book = Book.open('workbook.xls')

Opening a workbook with a block. 
The semantics is similar to, e.g.,  +File.open+.

  Book.open('workbook.xls') do |book|
    # do something
  end

Options are 
  
  +:default_excel+, +:force_excel+, +:if_absent+, +:if_unsaved+, +:if_obstructed+, 
  +:read_only+, +:visible+, +:check_compatibility, and +:update_links+. 

Valid values for +:default_excel+ are +:current+ (or +:active+, or +:reuse+), +:new+ or some Excel instance, for +:force_excel+ : +:current+ (or +:active+, or +:reuse+), +:new+ or some Excel instance, for +:if_unsaved+ : +:raise+, +:accept+, +:forget+, +:alert+ and +:new_excel+, for +:if_obstructed+ : +:raise+, +:save+, +:close_if_saved+, +:forget+, +:alert+ and +:new_excel+ , for +:if_absent+ : +:raise+ and +:create+, for +:update_links+ : +:never+, +:always+, +:alert+. The others are Boolean.

Remark: Doing updating links seems to be dependent on calculation mode: updates happen, if the calcultion mode is automatic, does not happen, if calculation mode is manual.

Here are a few examples:

Opening a workbook in the Excel instance where it was opened before most recently, if it was opened beefore and this Excel instance is alive. Otherwise opening it in a running Excel, if it exists, or in a new Excel.

Opening a workbook in the Excel instance where it was opened before most recently, if it was opened before and this Excel instance is alive. Otherwise opening it in a new Excel instance.

  book = Book.open('workbook.xls', :default_excel => :new)

Opening a workbook in the Excel instance where it was opened before most recently, if it was opened before and this Excel instance is alive. Otherwise opening it in a given Excel instance.

  book = Book.open('workbook.xls', :default_excel => excel1)

Opening a workbook in a new Excel instance, no matter if the workbook was opened before and if the old Excel instance is alive.

  book = Book.open('workbook.xls', :force_excel => :new)

Opening a workbook in a given Excel instance, no matter if the workbook was opened before and if the old Excel instance is alive.

  book = Book.open('workbook.xls', :force_excel => excel1)

Opening a workbook in a new Excel instance and make the window of the workbook visible.

  book = Book.open('workbook.xls', :force_excel => :new, :visible => true)

If a workbook contains unsaved changes and a workbook with the same filename shall be opened, then Excel gives an alert message.
The option +:if_unsaved+ manages this case. For example, +:if_unsaved+ => +:accept+  indicates that the workbook remains open, but no error is raised, i.e. the program can continue.

  book = Book.open('workbook.xls', :if_unsaved => :accept)

If a workbook is open and a workbook with the same name but in different path shall be opened, then the first workbook blocks opening the other workbook. The option +:if_obstructed+ handles this situation. For example, +:if_obstructed+ => +:forget+ causes the old workbook to close and to open the new workbook.

  book = Book.open('path/workbook.xls', :if_obstructed => :forget)

Opening linked workbooks for EXCEL 2007 is supported

=== Closing a workbook.

  book.close

There is one option: : +:if_unsaved+. Valid values for this option are +:raise+, +:save+, +:forget+, +:alert+ and +:keep_open+. Example:

Closing the workbook and saving it before if it has unsaved changes.

  book.close(:if_unsaved => :save)

=== Reopening a workbook.

A special feature of robust_excel_ole is that it allows to reopen workbooks after closing them.

  book = Book.open('workbook.xls')
  book.close
  book.reopen

The closed workbook is now alive again, i.e. is open and responds to Excel methods.
This feature is a result of providing identity transparence and storing the file name.

=== The Book objects and transperence identity

An Excel file (or workbook) is represented by a Book object. A Book object is defined by the full name of the workbook and the Excel instance in which it is opened. RobustExcelOle aims to ensure identity transperency.
Identity transparence means that the same Book objects refer to the same Excel files, and vice versa.
In other words, a Book objects is a proxy of an Excel file.

=== Promoting a workbook to a Book object

A Book object can be created when giving an Excel workbook.

   book = Book.new(win32ole_workbook)

=== Saving a workbook.

  book.save

Saving a workbook with a file name.

  book.save_as('another_workbook.xls')

The options are +:if_exists+ and +if_obstructed+. 

Saving a workbook and overwriting the file if it exists before.

  book.save_as('another_workbook.xls', :if_exists => :overwrite)

If a workbook is blocking the workbook that should be saved, then the former one can be saved and closed before.

  book = Book.open('workbook.xls')
  book2 = Book.open('another_workbook.xls')
  book2.save_as('dir/workbook.xls', :if_exists => :overwrite, :if_obstructed => :save)

=== Unobtrusively opening a workbook

The method +unobtrusively+ enables the user to read or modify a workbook, no matter if it is open in some Excel instance, if it is saved or unsaved, and if it is writable or not. When opening a workbook unobtrusively, its status remains unchanged. This status includes, whether the workbook is opened or closed, saved or unsaved, readonly or writable. 

Some options determine the Excel instance in which a closed workbook is opened. The option +:current+ (or +:active+, or +:reuse+) (default) indicates that the closed workbook is opened in the Excel instance where the workbooks is opened, if such an Excel instance exists, otherwise that another Excel instance is reused. The option +:hidden+ provokes that the closed workbook is opened in a separate Excel instance that is not visible and has no DisplayAlerts. Any following closed workbook would be opened in this Excel instance as well when using this option. Moreover, an Excel instance can be given directly where to open the closed workbook.

Further options are +:read_only+, +:readonly_excel+, and +:keep_open. The option +:readonly_excel+ chooses whether a book that is opened in read only mode. If the workbook is opened as read only, then the option +:readonly_excel+ determines whether to close the workbook and open it as writable in the Excel instance where it was open so far, or to open it as writable in another running Excel instance, if such an instance exists, or to open it in a new Excel instance. Moreover, there are the options +:visible+, and +:check_compatiblity.

  Book.unobtrusively('workbook.xls', :current, :read_only => false, :keep_open => false) do |book|
    # some modification
    sheet = book[0]
    sheet[1,1] = "c" 
  end
  
The methods +for_reading+ and +for_modifying+ are methods for unobtrusively reading or modifying.

  Book.for_modifying('workbook.xls') do |book|
    # some modification
    sheet = book[0]
    sheet[1,1] = "c" 
  end

=== Checking whether the workbook is alive.

This method finds out whether the Excel workbook that is referenced by the Book object responds to methods.

  if book.alive? then sheet = book[0] end

=== Getting and setting the contents of a range in a workbook.

Getting the contents of a range.

  book["name"] 
  => "value"

or

  book.nameval("name")
  => "value"

Setting the contents of a range.

  book["name"] = "value"

or

  book.set_nameval("name") = "value"

=== Activating a workbook.

Bring the window of a workbook to the foreground, make it available for keyboard inputs, and make the Excel instance visible.

  book.activate


=== Making the window of the workbook visible

Open a workbook and make the Excel instance and the window of the workbook visible.

  book = Book.open('workbook.xls', :visivble => true)

Make the window of the workbook invisible.

  book.visible = false

Make the window of the workbook visible.

  book.visible = true

=== Making an Excel visible or invisible, and enable and disable DisplayAlerts.

Make an Excel visible

  book.excel.visible = true

Enable DisplayAlerts.

  book.excel.displayalerts = true


=== Accessing a sheet.

Accessing the first sheet.

  sheet = book.sheet(1)

or

  sheet = book.first_sheet  

Accessing the last sheet.

  sheet = book.last_sheet  

Accessing a sheet with the sheet name.

  sheet = book.sheet('Sheet1')

Accessing sheet objects using the methods Book#each.

  book.each do |sheet|               
    # do something with sheet
  end

=== Accessing a row or a column.

A sheet object is enumerable. Use the methods Sheet#each_column, Sheet#each_row or Sheet#each.

  sheet.each do |cell|
    # do something with cell
    # read every row every column
  end

  sheet.each_row do |row|
    # do something with row
  end

  sheet.each_column do |column|
    # do something with column
  end

=== Accessing a cell.

Reading a cell from a sheet object.

  sheet[1, 1]  => first cell (first row, first column).

Reading a cell from a range object.

  row_range[1]  => first cell in row_range
  column_range[2] => second cell in column_range

Methods to a cell are just delegated. Example:

Reading the value of a cell.

  cell = sheet[1,1]
  cell.Value  => value of the cell.

Writing a cell

  sheet[1,1] = "new_value"

=== Accessing a range of a row or column. 

Accessing a range of a row.

  sheet.row_range(1)  => first row
  sheet.row_range(1, 1..3 )  => first three cells of the first row  

Accessing a range of a column.

  sheet.col_range(3)  => third column
  sheet.col_range(3, 1..2)  => first two cells of the third column

=== Naming a cell

Naming or renaming a cell range given its address.

  book.set_name(1,1,"name")

=== Getting and setting the contents of a named range in a worksheet

Getting the value of a range.

  sheet[name]
  
or

  sheet.nameval(name)

Setting the value of a range.

  book[name] = value

or

  book.set_nameval(name,value)

=== Getting and setting the contents of a named range in a Worksheet directly

Getting the value of a range.

  sheet.rangeval(name)

Setting the value of a range.

  book.set_rangeval(name,value)

=== Copying or Adding an sheet.

Adding (appending) an empty sheet.

  book.add_empty_sheet

Adding an empty sheet and naming it.

  book.add_empty_sheet(:as => 'sheet_name')

Adding an empty sheet with a name before another sheet.

  book.add_empty_sheet(:as => 'new_name', :before => another_sheet)

Copying a sheet and adding (appending) it.

  book.copy_sheet sheet

Copying a sheet after a another sheet and naming it.

  book.copy_sheet(sheet, :as => 'new_name', :after => another_sheet)

Copying a sheet, if a sheet is given, adding an empty sheet, if no sheet is given.

  book.add_or_copy_sheet

  book.add_or_copy_sheet(sheet, :as => 'new_name', :after => another_sheet)  

=== Creating and reusing an Excel instance.

Creating a new Excel.

  excel1 = Excel.create

or 

  excel1 = Excel.new(:reuse => false)  

Resusing a runnin Excel instance.

  excel2 = Excel.current

or 

  excel2 = Excel.new(:reuse => true)  

Options are +:reuse+ (+true+, +false+), +:visible+ (+true+, +false+) and +:displayalerts+ (+true+, +false+, +:if_visible+).  

Promoting an Excel instance represented as WIN32OLE object to an Excel object

  excel = Excel.new(win32ole_object)

=== Making a Excel visible or invisible

Creating a new Excel and making it visible.

  excel1 = Excel.create(:visible => true)

or

  excel1 = Excel.new(:reuse => false, :visible => true)  

Reusing a Excel and making it invisible.

  excel2 = Excel.current(:reuse => false, :visible => false)  

or 

  excel2 = Excel.new(:reuse => false, :visible => false)

=== Enabling or disabling DisplayAlerts

Enabling DisplayAlerts.

  excel3 = Excel.new(:reuse => true, :displayalerts => true)

Disabling DisplayAlerts.
  
  excel3 = Excel.current(:reuse => true, :displayalerts => false)

Enabling DisplayAlerts whenever the Excel instance is visible.

  excel3 = Excel.current(:reuse => true, :displayalerts => :if_visible)

=== Making all workbooks visible or invisible

Making all workbooks visible.

  excel1.workbooks_visible true  

Making all workbooks invisible.

  excel1.workbooks_visible false   

=== Closing an Excel

  excel = Excel.current
  excel.close

The options are +:if_unsaved+ and +:hard+ . Values for :if_unsaved+ are +:raise+, +:save+, +:forget+ and +:keep_open+.

Closing the Excel instance, saving unsaved workbooks and terminating the Excel process hard.

  excel.close(:if_unsaved => :save, :hard => true)

=== Closing Excel instances opened via RobustExcelOle.

  Excel.close_all

The options are +:if_unsaved+ and +:hard+ . Values for :if_unsaved+ are +:raise+, +:save+, and +:forget+. Example:

Closing all Excel instances, saving unsaved workbooks and terminating the Excel processes softly.

  Excel.close_all(:if_unsaved => :save, :hard => false) 

=== Terminating all Excel processes

  Excel.kill_all

=== Recreating an Excel instance    

Reopening the closed Excel instance. This includes reopening all workbooks that were open in that Excel instance.

  excel.close
  excel.recreate

The options are :reopen_workbooks, :visible and :displayalerts.

  excel.recreate(:reopen_workbooks => true, :visible => true, :displayalerts => true)

=== Providing Excel instances

Providing all Excel instances (opened via RobustExcelOle) as objects of the class Excel

  Excel.excel_objects  

=== Making Excel visible or invisible

Making Excel visible.

  excel = Excel.create
  excel.visible = true

Making Excel invisible

  excel.visible = false

=== Turning on or off Displayalerts.

Turning DisplayAlerts on.

  excel = Excel.create
  excel.displayalerts = true

Turning DisplayAlerts off.

  excel.displayalerts = false

Turning on and off in a block.

  excel = Excel.create
  excel.with_displayalerts true do
    book = Book.open('workbook.xls')
  end

=== Setting Calculation mode.

Setting calculation mode to manual. Options are +:manual+ and +:automatic+
The calculation mode is not reset after the block.

  excel = Excel.create
  book = Book.open('workbook.xls')
  excel.with_calculation(:manual) do 
    # do something
  end

=== Getting and setting the contents of a named range in an Excel application

  excel = Excel.create
  book = Book.open('another_workbook.xls')

Getting the value of a range.

  excel[name]
  
or

  excel.nameval(name)

Setting the value of a range.

  excel[name] = value

or

  excel.set_nameval(name,value)

=== Getting and setting the contents of a named range in an Excel application directly

Getting the value of a range.

  excel.rangeval(name)

Setting the value of a range.

  excel.set_rangeval(name,value)


=== Examples

=== Example 1 

Opening a book.

  book = Book.open('workbook.xls')

Accessing a sheet via its name.

  sheet = book['Sheet1']
  
Changing the first cell.

  sheet[0,0] = "new"
  
Saving the book.

  book.save

Saving the book with a different name, and overwrite if a file with this name exists.

  book.save_as('different_workbook.xls', :if_exists => :overwrite)

Closing the book.

  book.close  

=== Example 2

Opening a workbook.

  book = Book.open('workbook.xls')

Opening the book in a new Excel instance and make it visible.

  new_book = Book.open('workbook.xls', :force_excel => :new, :visible => true)

Opening the book in a given Excel instance.

  another_book = Book.open('workbook.xls', :force_excel => book.excel)

Closing the books.

  book.close
  new_book.close
  another_book.close

Reopening the workbook.

  reopened_book = book.reopen

The writable workbook is being prefered.  

  reopened_book === book
  => true

Opening another workbook.
Since the workbook was not open before, reopening the workbook fails and the :default_excel option applies.
According to :default_excel => :new a new Excel is created, and the workbook is opened there.

  different_book = Book.open('different.xls', :default_excel => :new)
  

=== Example 3

Opening a workbook.

  book = Book.open('workbook.xls')

Adding a copy of the first sheet after the second sheet.

  book.add_sheet(book[0], :as => 'Sheet1_copy', :after => book[1])

Opening a new workbook with the same name in a new Excel. Leave the workbook that contains unsaved changes in the old Excel.

  new_book = Book.open('workbook.xls', :if_unsaved => :new_excel)

Accessing a sheet and change a cell.

  sheet = new_book[0]
  sheet[1,1] = "another"

Opening another workbook with the same name in the running Excel. The book that contains unsaved changes will be closed before. 

  third_book = Book.open('workbook.xls', :if_unsaved => :forget)

Adding a sheet.

  third_book.add_sheet

Closing the workbook without saving it.

  third_book.close(:if_unsaved => :forget)

Closing the first workbook and saving it before.

  book.close(:if_unsaved => :save)

=== Example 4

Opening a workbook.

  book1 = Book.open('workbook.xls')

Opening a book with the same name in a different path. Close the old workbook.

  book2 = Book.open('more/workbook.xls', :if_obstructed => :forget)

Changing its cell.

  sheet = book2[0]
  sheet[1,1] = "new"

Opening a workbook with the same name in a different path. The old workbook that was modified will be saved and closed before.

  book3 = Book.open('workbook.xls', :if_obstructed => :save)

Opening a workbook with the same name in a different path. The other workbook will be closed, because it does not contain unsaved changes.

  book4 = Book.open('more/workbook.xls', :if_obstructed => :close_if_unsaved)

Closing the workbook.

  book4.close


=== Example 5

Opening a workbook.

  book = Book.open('workbook.xls')

Printing its first cell.

  sheet = book[0]
  p "1st cell: #{sheet[1,1].Value}"

Unobtrusively modify the workbook.

  Book.unobtrusively('workbook.xls') do |book|
    sheet = book[0]
    sheet[1,1] = 'simple'
  end

The workbook is modified, but its status is unchanged.

  new_sheet = book[0]
  not (new_sheet[1,1].Value == sheet[1,1].Value) 
  => true

  book.saved 
  => true


=== More Details

For more details about usage: see link:https://github.com/Thomas008/robust_excel_ole/blob/master/README_detail.rdoc

=== Development

robust_excel_ole started as a simple fork from tomiacannondale's wrap_excel adapted to Ruby 1.8.6.
The functionality of wrap_excel is optimised and extended by new features.
Most notable extensions include:
* workbooks can be opened in already running Excel instances (instead of opening a new Excel whenever a book is opened)
* a workbook management system stores all workbooks that have been open. This workbook store is being used, e.g., for reopening a workbook that has been closed before. It provides transparency identity, i.e., equal Excel workbooks correspond to equal Book objects of RobustExcelOle.

Some features in robust_excel_ole that are not compatible with wrap_excel:
* +open+ uses by default a running Excel instance instead of creating a new one,
  and opens a workbook by default in writable mode instead of read_only 
* +close+ closes the workbook instead of closing all workbooks and the Excel instance.
* +save_as+ instead of +save+.


=== Want to do more things

If you want to do something that not provide a function, you can use win32ole methods.

== Support

This is work in progress. Please contact us and to report issues and feature requests to github Issues. 
https://github.com/Thomas008/robust_excel_ole/issues

== Collaborate

Please pull request on github.

== Author

thomas mailto:Thomas.Raths@gmx.net

== License

MIT License. For more imformation, please see LICENSE.
