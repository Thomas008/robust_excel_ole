= RobustExcelOle

This ruby gem automates modifying, reading and writing Excel files.
It supports simultaneously running Excel instances and user interactions.
RobustExcelOle deals with various cases of Excel and user behaviour,
and implements workarounds for some Excel bugs.
The gem provides convenient methods for common tasks, and facilitates referenced libraries.
It supports Excel 2010 and Excel 2007.

RobustExcelOle works by sending VBA methods via Win32OLE.
Moreover, it implements a management system and keeps track of Excel files and Excel instances.

== Requirements

* Ruby 1.8.6 or higher

== Install

  gem install robust_excel_ole

== Usage

  require 'robust_excel_ole'
  include RobustExcelOle

=== Opening a workbook.

Example:
  
  book = Book.open('workbook.xls')

You can also open a workbook with a block. 
The semantics is similar to, e.g.,  +File.open+.

  Book.open('workbook.xls') do |book|
    # do something
  end

The options of +open+ are:

+:default_excel+::   open the workbook in the Excel instance where it was opened before most recently,
if the book was opened before and this Excel instance is alive. Otherwise open it in the current (+:current+, or +:active+, or +:reuse+), a new (+:new+) or a given Excel instance (default: +:current+)
+:force_excel+::     open the workbook in the current (+:current+, +:active+, or +:reuse+), a new (+:new+) or given Excel instance 
+:if_absent+::       if the workbook with the given file name does not exist, then raise an error or create a file
+:if_unsaved+::      specify behaviour it the workbook was unsaved (+:raise+, +:forget+, +:save+, +:alert+, +:new_excel+)
+:if_obstructed+::   specidy behaviour if the workbook is blocked by another book (default: +new_excel+)
+:read_only+::       open in read-only mode (default: +false+) 
+:check_compatibility:: check compatibility when saving (default: +false+)
+:update_links+ :     user is never (default) or always being asked how to update links
+:visible+::         make the window of the workbook visible (default: +true) or invisible 
  
Here are a few examples: 

When you want to open a workbook that was not opened before, or reopen a workbook that was open in an Excel instance that is now closed, in the current (active) Excel instance, then use

  Book.open('workbook.xls')

or
  
  Book.open('workbook.xls', :default_excel => :current)

In case you want to open such a workbook in a new Excel instance, then use

  Book.open('workbook.xls', :default_excel => :new)

When you want to open a workbook in a new Excel instance, no matter if it was opened before, you can write

  Bool.open('workbook.xls', :force_excel => :new)

You can also specify an Excel instance

  excel1 = Excel.create
  # something
  Book.open('workbook.xls', :force_excek => excel1)

If you want to open the workbook and make its window visible, then use

  book = Book.open('workbook.xls', :visible => true)

If a workbook contains unsaved changes and a workbook with the same filename shall be opened, then Excel stops with an alert message.
Here the option +:if_unsaved+ manages this case. The default value +:raise+ causes an error message. The value +:forget+ would cause to discard the unsaved workbook. The value +:accept+ indicates that the workbook remains open, but no error is raised, i.e. the program can continue.

  book = Book.open('workbook.xls', :if_unsaved => :accept)

If a workbook is open and a workbook with the same name but in different path shall be opened, then the first workbook blocks opening the other workbook, and Excel would stop with an alert message. The option +:if_obstructed+ handles this situation. Similar as described above, the values +:raise+, +:forget+ and +:accept+ would cause an error message, and discarding or accepting the old workbook.

  book = Book.open('path/workbook.xls', :if_obstructed => :forget)

Remarks:

Opening linked workbooks is supported.

Doing updating links seems to be dependent on calculation mode: updates happen, if the calcultion mode is automatic, and does not happen, if calculation mode is manual.

=== Closing a workbook.

  book.close

This method has the option +:if_unsaved+. Valid values for this option are +:raise+, +:save+, +:forget+, +:alert+ and +:keep_open+. For example, if you want to close the workbook and save it before if it has unsaved changes:

  book.close(:if_unsaved => :save)

=== Reopening a workbook.

A special feature of RobustExcelOle is that it allows to reopen workbooks after closing them.

  book = Book.open('workbook.xls')
  book.close
  book.reopen

The closed workbook is now alive again, i.e. is open and responds to Excel methods.
This feature is a result of providing identity transparence and storing the file name.

=== The Book objects and transperence identity

An Excel file (or workbook) is represented by a Book object. A Book object is defined by the full name of the workbook and the Excel instance in which it is opened. RobustExcelOle aims to ensure identity transperency.
Identity transparence means that the same Book objects refer to the same Excel files, and vice versa.
In other words, a Book objects is a proxy of an Excel file.

=== Promoting a workbook to a Book object

A Book object can be created when giving an Excel workbook.

   book = Book.new(win32ole_workbook)

=== Saving a workbook.

  book.save

When you want to save a workbook with a file name, then use

  book.save_as('another_workbook.xls')

The options are +:if_exists+ and +if_obstructed+. 

For example, if you want to overwrite a workbook, then use

  book.save_as('another_workbook.xls', :if_exists => :overwrite)

If a workbook is blocks the workbook that should be saved, then the former one can be saved and closed before.

  book = Book.open('workbook.xls')
  book2 = Book.open('another_workbook.xls')
  book2.save_as('dir/workbook.xls', :if_exists => :overwrite, :if_obstructed => :save)

Values of +:if:obstructed+ are +:raise+, +:forget+, +:save+ and +:close_if_saved+. 

=== Unobtrusively opening a workbook

The method +unobtrusively+ enables the user to read or modify a workbook, no matter if it is open in some Excel instance, if it is saved or unsaved, and if it is writable or not. When opening a workbook unobtrusively, its status remains unchanged. This status includes, whether the workbook is opened or closed, saved or unsaved, readonly or writable. 

Some options determine the Excel instance in which a closed workbook is opened. The option +:current+ (or +:active+, or +:reuse+) (default) indicates that the closed workbook is opened in the Excel instance where the workbooks is opened, if such an Excel instance exists, otherwise that another Excel instance is reused. The option +:hidden+ provokes that the closed workbook is opened in a separate Excel instance that is not visible and has no DisplayAlerts. Any following closed workbook would be opened in this Excel instance as well when using this option. Moreover, an Excel instance can be given directly where to open the closed workbook.

Further options are +:read_only+, +:readonly_excel+, and +:keep_open. The option +:readonly_excel+ chooses whether a book that is opened in read only mode. If the workbook is opened as read only, then the option +:readonly_excel+ determines whether to close the workbook and open it as writable in the Excel instance where it was open so far, or to open it as writable in another running Excel instance, if such an instance exists, or to open it in a new Excel instance. Moreover, there are the options +:visible+, and +:check_compatiblity as for the method +open+.

  Book.unobtrusively('workbook.xls', :if_closed => :current, :read_only => false, :keep_open => false) do |book|
    # some modification
    sheet = book[0]
    sheet[1,1] = "c" 
  end
  
The methods +for_reading+ and +for_modifying+ are methods for unobtrusively reading or modifying.

  Book.for_modifying('workbook.xls') do |book|
    # some modification
    sheet = book[0]
    sheet[1,1] = "c" 
  end

=== Checking whether the workbook is alive.

This method finds out whether the Excel workbook that is referenced by the Book object responds to methods.

  if book.alive? then sheet = book[0] end

=== Getting and setting the contents of a range in a workbook.

Getting the contents of a range.

  book["name"] 
  => "value"

or

  book.nameval("name")
  => "value"

Setting the contents of a range.

  book["name"] = "value"

or

  book.set_nameval("name") = "value"

=== Bringing a workbook to the focus.

When you want to make the workbook visible and available for keyboard inputs, use

  book.focus

=== Making the window of the workbook visible

You can make the window of the workbook invisible or visible

  book.visible = false
  book.visible = true

=== Making an Excel visible or invisible, and enable and disable DisplayAlerts.

Make an Excel visible

  book.excel.visible = true

Enable DisplayAlerts.

  book.excel.displayalerts = true


=== Accessing a sheet.

You can access a sheet by giving the number

  sheet = book.sheet(1)

or its name

  sheet = book.sheet('Sheet1')

You can get the first and last sheet with

  sheet = book.first_sheet  

and

  sheet = book.last_sheet  

You can access all sheet objects by using the methods Book#each.

  book.each do |sheet|               
    # do something with sheet
  end

=== Accessing a row or a column.

A sheet object is enumerable. Use the methods Sheet#each_column, Sheet#each_row or Sheet#each.

  sheet.each do |cell|
    # do something with cell
    # read every row every column
  end

  sheet.each_row do |row|
    # do something with row
  end

  sheet.each_column do |column|
    # do something with column
  end

=== Accessing a cell.

Reading a cell from a sheet object

  sheet[1, 1]  => first cell (first row, first column).

Reading a cell from a range object

  row_range[1]  => first cell in row_range
  column_range[2] => second cell in column_range

Methods to a cell are just delegated. Example:

Reading the value of a cell.

  cell = sheet[1,1]
  cell.Value  => value of the cell.

Writing a cell

  sheet[1,1] = "new_value"

=== Accessing a range of a row or column. 

You access a range of a row by giving the number of the row, and optionally, the range of the cell numbers.

  sheet.row_range(1)  => first row
  sheet.row_range(1, 1..3 )  => first three cells of the first row  

Accessing a range of a column.

  sheet.col_range(3)  => third column
  sheet.col_range(3, 1..2)  => first two cells of the third column

=== Naming a cell

You can (re-) name a cell range.

  book.set_name(1,1,"name")

=== Getting and setting the contents of a named range in a worksheet

You get the value of a range by 

  sheet[name]
  
or

  sheet.nameval(name)

Setting the value of a range.

  book[name] = value

or

  book.set_nameval(name,value)

=== Getting and setting the contents of a named range in a Worksheet directly

Getting the value of a range.

  sheet.rangeval(name)

Setting the value of a range.

  book.set_rangeval(name,value)

=== Copying or Adding an sheet.

Adding (appending) an empty sheet.

  book.add_empty_sheet

Adding an empty sheet and naming it.

  book.add_empty_sheet(:as => 'sheet_name')

Adding an empty sheet with a name before another sheet.

  book.add_empty_sheet(:as => 'new_name', :before => another_sheet)

Copying a sheet and adding (appending) it.

  book.copy_sheet sheet

Copying a sheet after a another sheet and naming it.

  book.copy_sheet(sheet, :as => 'new_name', :after => another_sheet)

Copying a sheet, if a sheet is given, adding an empty sheet, if no sheet is given.

  book.add_or_copy_sheet

  book.add_or_copy_sheet(sheet, :as => 'new_name', :after => another_sheet)  

=== Creating and reusing an Excel instance.

When you want to start a new Excel, use

  excel1 = Excel.create

or 

  excel1 = Excel.new(:reuse => false)  

When you want to reuse an already running Excel instance, write

  excel2 = Excel.current

or 

  excel2 = Excel.new(:reuse => true)  

Options are +:reuse+ (+true+, +false+), +:visible+ (+true+, +false+) and +:displayalerts+ (+true+, +false+, +:if_visible+).  

You can also promote an Excel instance represented as WIN32OLE object to an Excel object.

  excel = Excel.new(win32ole_object)

=== Making a Excel visible or invisible

Creating a new Excel and making it visible.

  excel1 = Excel.create(:visible => true)

or

  excel1 = Excel.new(:reuse => false, :visible => true)  

or 

  excel1 = Excel.create
  excel1.visible = true  


=== Enabling or disabling DisplayAlerts

You can enable DisplayAlerts with, e.g. 

  excel1 = Excel.new(:reuse => true, :displayalerts => true)

or 

  excel1 = Excel.current
  excel1.displayalerts = true

and turn DisplayAlerts off with

  excel1.displayalerts = false

You can turn off and off DisplayAlerts in a block.

  excel = Excel.create
  excel.with_displayalerts false do
    # do something
  end

=== Making all workbooks visible or invisible

  excel1.workbooks_visible true  

  excel1.workbooks_visible false   

=== Bringing an Excel instance to the focus

Set the window of an Excel instance to the foreground.

  excel1.focus

=== Closing an Excel

  excel = Excel.current
  excel.close

The method +close has the option +:if_unsaved+ with the values +:raise+, +:save+, +:forget+ and +:alert+.

For example, if you want to close an Excel instance and save unsaved workbooks, use

  excel.close(:if_unsaved => :save)

=== Closing all Excel instances

  Excel.close_all

This method has the option +:if_unsaved+ as described above. For example, if you want to close all Excel instances containing saved workbooks and raise an error for Excel instances with unsaved workbooks, use

  Excel.close_all(:if_unsaved => :raise)   

=== Terminating all Excel processes

  Excel.kill_all

This method kills all Excel instances no matter whether they contain unsaved workbooks.  

=== Recreating an Excel instance    

Closed Excel instances can also be reopened. This includes reopening all workbooks that were open in that Excel instance.

  excel.close
  excel.recreate

The options are :reopen_workbooks, :visible and :displayalerts.

  excel.recreate(:reopen_workbooks => true, :visible => true, :displayalerts => true)

=== Providing Excel instances

Providing all Excel instances (opened via RobustExcelOle) as objects of the class Excel

  Excel.excel_processes 

=== Setting Calculation mode.

Setting calculation mode to manual. Options are +:manual+ and +:automatic+
The calculation mode is not reset after the block.

  excel = Excel.create
  book = Book.open('workbook.xls')
  excel.with_calculation(:manual) do 
    # do something
  end

=== Getting and setting the contents of a named range in an Excel application

  excel = Excel.create
  book = Book.open('another_workbook.xls')

Getting the value of a range.

  excel[name]
  
or

  excel.nameval(name)

Setting the value of a range.

  excel[name] = value

or

  excel.set_nameval(name,value)

=== Getting and setting the contents of a named range in an Excel application directly

Getting the value of a range.

  excel.rangeval(name)

Setting the value of a range.

  excel.set_rangeval(name,value)


=== Examples

=== Example 1 

We open a workbook.

  book = Book.open('workbook.xls')

Then we access a sheet via its name.

  sheet = book['Sheet1']
  
Now we can modify the first cell.

  sheet[0,0] = "new"
  
Then we save the workbook.

  book.save

We can also save the workbook with a different name, and overwrite if a file with this name already exists.

  book.save_as('different_workbook.xls', :if_exists => :overwrite)

Finally we close the workbook.

  book.close  

=== Example 2

We open a workbook.

  book = Book.open('workbook.xls')

open it also in a new Excel instance and make it visible.

  new_book = Book.open('workbook.xls', :force_excel => :new, :visible => true)

and open another workbook in a the first Excel instance.

  another_book = Book.open('another_workbook.xls', :force_excel => book.excel)

Then we close the workbooks.

  book.close
  new_book.close
  another_book.close

We reopen the first workbook.

  reopened_book = book.reopen

The writable workbook is being prefered.  

  reopened_book === book
  => true

We want to open yet another workbook. Since the workbook was not open before, reopening the workbook fails and the :default_excel option applies. According to :default_excel => :new a new Excel is created, and the workbook is opened there.

  different_book = Book.open('different.xls', :default_excel => :new)
  

=== Example 3

Open a workbook.

  book = Book.open('workbook.xls')

We want to add a copy of the first sheet and insert it after the second sheet.

  book.add_sheet(book[0], :as => 'Sheet1_copy', :after => book[1])

Then we open a new workbook with the same name in a new Excel, and leave the workbook that contains unsaved changes in the old Excel.

  new_book = Book.open('workbook.xls', :if_unsaved => :new_excel)

We acccess the first sheet and change the first cell.

  sheet = new_book[0]
  sheet[1,1] = "another"

Then we open a workbook with the same name in the running Excel while discarding the workbook that contained unsaved changes.

  third_book = Book.open('workbook.xls', :if_unsaved => :forget)

Now we add a sheet.

  third_book.add_sheet

and close the workbook without saving it.

  third_book.close(:if_unsaved => :forget)

We close the first workbook and save it before.

  book.close(:if_unsaved => :save)

=== Example 4

We open a workbook.

  book1 = Book.open('workbook.xls')

Then we open a workbook with the same name in a different path, while closing the workbook opened before.

  book2 = Book.open('more/workbook.xls', :if_obstructed => :forget)

We change its first cell.

  sheet = book2[0]
  sheet[1,1] = "new"

Now we open a workbook with the same name again in a different path. while saving and closing the other workbook.

  book3 = Book.open('workbook.xls', :if_obstructed => :save)

Then we open a workbook with the same name in a different path. 
The other workbook will be closed, because it does not contain unsaved changes.

  book4 = Book.open('more/workbook.xls', :if_obstructed => :close_if_unsaved)


Finally we close this workbook.

  book4.close


=== Example 5

We open a workbook

  book = Book.open('workbook.xls')

and print its first cell.

  sheet = book[0]
  p "1st cell: #{sheet[1,1].Value}"

Then we unobtrusively modify the workbook.

  Book.unobtrusively('workbook.xls') do |book|
    sheet = book[0]
    sheet[1,1] = 'simple'
  end

The workbook is modified, but its status is unchanged.

=== Development

RobustExcelOle started as a simple fork from tomiacannondale's wrap_excel adapted to Ruby 1.8.6.
The functionality of wrap_excel is optimised and extended by new features.
Most notable extensions include:
* workbooks can be opened in already running Excel instances (instead of opening a new Excel whenever a book is opened)
* a workbook management system stores all workbooks that have been open. This workbook store is being used, e.g., for reopening a workbook that has been closed before. It provides transparency identity, i.e., equal Excel workbooks correspond to equal Book objects of RobustExcelOle.

Some features in RobustExcelOle that are not compatible with wrap_excel:
* +open+ uses by default a running Excel instance instead of creating a new one,
  and opens a workbook by default in writable mode instead of read_only 
* +close+ closes the workbook instead of closing all workbooks and the Excel instance.
* +save_as+ instead of +save+.


=== Want to do more things

If you want to do something that not provide a function, you can use win32ole methods.

== Support

This is work in progress. Please contact us and to report issues and feature requests to github Issues. 
https://github.com/Thomas008/robust_excel_ole/issues

== Collaborate

Please pull request on github.

== Author

thomas mailto:Thomas.Raths@gmx.net

== License

MIT License. For more imformation, please see LICENSE.
